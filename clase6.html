<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Clase 6</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="common.css">
    <!-- Solarized theme -->
    <link id="light-theme" rel="stylesheet" href="dist/theme/solarized.css">
    <!-- Moon theme -->
    <link id="dark-theme" rel="stylesheet" href="dist/theme/moon.css" disabled>

    <link rel="stylesheet" href="plugin/highlight/atom-one-dark.css">
	<!-- Favicon Links -->
	<link rel="icon" type="image/png" sizes="16x16" href="media/favicon/favicon-16x16.png">
	<link rel="icon" type="image/png" sizes="32x32" href="media/favicon/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="192x192" href="media/favicon/android-chrome-192x192.png">
	<link rel="icon" type="image/png" sizes="512x512" href="media/favicon/android-chrome-512x512.png">
	<link rel="apple-touch-icon" sizes="180x180" href="media/favicon/apple-touch-icon.png">
</head>

<body data-theme="light">
    <a href="index.html" class="back-link">Volver</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
        <svg class="icon sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <circle cx="12" cy="12" r="5"></circle>
            <line x1="12" y1="1" x2="12" y2="3"></line>
            <line x1="12" y1="21" x2="12" y2="23"></line>
            <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
            <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
            <line x1="1" y1="12" x2="3" y2="12"></line>
            <line x1="21" y1="12" x2="23" y2="12"></line>
            <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
            <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
        </svg>
        <svg class="icon moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
        </svg>
    </button>
    <div class="reveal">
        <div class="slides">
            <!--TEXTO IZQUIERDA - CÓDIGO DERECHA -->
            <section data-auto-animate>
                <h1 data-id="titlepandas">Análisis de datos con Pandas</h1>
            </section>
            <section data-auto-animate>
                <h1 data-id="titlepandas">Análisis de datos con Pandas</h1>
                <div style="display: flex; gap: 4rem;">
                    <div>
                        <p style="align-content: baseline;">
                        <ul>
                            <li style="margin-bottom: 10px;">Pandas (cuyo nombre proviene de <b>Pan</b>el <b>Da</b>ta)
                                es una librería
                                de Python diseñada para la manipulación y el análisis de datos <em>estructurados</em>
                                (datos tabulados, series temporales).</li>
                            <li style="margin-bottom: 10px;" class="fragment">Ofrece dos estructuras de datos
                                fundamentales:
                                <span class="monospace">Series</span> y <span class="monospace">DataFrame</span>.
                            </li>
                            <li style="margin-bottom: 10px;" class="fragment">Pandas está construido sobre NumPy.</li>
                            <li style="margin-bottom: 10px;" class="fragment">Hoy en día es una de las librerías
                                fundamentales para la ciencia de datos
                                junto a NumPy, SciPy, statsmodels, scikit-learn, matplotlib, etc.</li>
                            <li style="margin-bottom: 20px;" class="fragment">Algunos de sus principales usos
                                son:
                                <ul>
                                    <li class="fragment">La importación y exportación de datos a diferentes formatos:
                                        CSV, Excel, JSON, HTML, Stata, SQL, etc.</li>
                                    <li class="fragment">Seleccionar y filtrar datos; agregar, modificar y eliminar
                                        filas y columnas a tablas</li>
                                    <li class="fragment">Manejar datos faltantes (NaNs)</li>
                                    <li class="fragment">Realizar análisis estadísticos</li>
                                    <li class="fragment">Agrupar datos (<span class="monospace">groupby()</span>) y
                                        fusionar o combinar datasets (<span class="monospace">merge()</span>)</li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <div class="fragment">
                        <p style="align-content: baseline;">
                        <ul>
                            <li>Recursos adicionales:
                                <ul style="margin-top: 20px;">
                                    <li><a href="https://pandas.pydata.org/docs/getting_started/intro_tutorials/">Tutorial
                                            oficial de
                                            Pandas</a></li>
                                    <li><a href="https://pandas.pydata.org/docs/">Documentación completa</a></li>
                                    <li><a href="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf">Cheatsheet de
                                            comandos</a></li>
                                </ul>
                            </li>
                        </ul>
                    </div>
                    <aside class="notes">
                        Los DataFrames de Pandas están inspirados en los de R.
                        Pandas está pensado para trabajar con datos tabulares, heterogéneos. Numpy, con datos numéricos
                        homogéneos.
                        Pandas también puede exportar a LaTeX (no leer).
                        ChatGPT.
                    </aside>
            </section>
            <section data-background-iframe="https://pandas.pydata.org/Pandas_Cheat_Sheet.pdf"
                data-background-interactive data-preload></section>
            <section style="display: flex; flex-direction: column; align-items: left; gap: 2rem;">
                <h2>Series</h2>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 2rem;">
                    <div style="flex: 2; text-align: left;">
                        <ul>
                            <li>Una Serie es un array 1-dim cuya secuencia de valores está asociada a un <em>índice</em>
                                de etiquetas.</li>
                            <li class="fragment" data-fragment-index="1">Por defecto, el índice es numérico. Si la Serie
                                tiene longitud $N$, el
                                índice contendrá los enteros desde $0$ a $N - 1$.</li>
                            <li class="fragment" data-fragment-index="2">El índice nos permite seleccionar uno o varios
                                elementos a través de
                                sus etiquetas.</li>
                            <li class="fragment" data-fragment-index="3">¡Operar sobre la Serie a través de funciones de
                                NumPy no cambia el
                                índice!</li>
                            <li class="fragment" data-fragment-index="4"><span class="monospace">isnull()</span> nos
                                permite comprobar si hay
                                datos faltantes.</li>
                            <li class="fragment" data-fragment-index="5">¡Y las operaciones sobre varias series (e.g.
                                sumas) se alinean con
                                respecto a los índices!</li>
                        </ul>
                    </div>
                    <div style="flex: 2; text-align: left;" class="r-stack">
                        <pre style="height: 700px;"><code class="python" data-line-numbers>

                        </code></pre>
                        <pre style="height: 700px;" class="fragment" data-fragment-index="1"><code class="python" data-line-numbers>
datos = [3, -2, 0, 42]                            
obj = pd.Series(datos)
print(obj)
# 0     3
# 1    -2
# 2     0
# 3    42
# dtype: int64



# Creamos una serie especificanado un índice
obj2 = pd.Series(datos, index=['a', 'd', 'g', 'w'])
print(obj2)
# a     3
# d    -2
# g     0
# w    42
# dtype: int64

                        </code></pre>
                        <pre style="height: 700px;" class="fragment" data-fragment-index="2"><code class="python" data-line-numbers>
obj2 = pd.Series(datos, index=['a', 'd', 'g', 'w'])
print(obj2)
# a     3
# d    -2
# g     0
# w    42
# dtype: int64




# Selección de datos a través de etiquetas
print(obj2['a'])    # 3
obj2['w'] = 100 
print(obj2[['a', 'w']])  
# a      3
# w    100
# dtype: int64

                        </code></pre>
                        <pre style="height: 700px;" class="fragment" data-fragment-index="3"><code class="python" data-line-numbers>
# El filtrado y las operaciones mantienen las etiquetas
print(obj2[obj2 > 70])
# w    100
# dtype: int64
print(obj2 * 3)
# a      9
# d     -6
# g      0
# w    300
# dtype: int64
print(np.exp(obj2))
# a    2.008554e+01
# d    1.353353e-01
# g    1.000000e+00
# w    2.688117e+43
# dtype: float64

                        </code></pre>
                        <pre style="height: 700px;" class="fragment" data-fragment-index="4"><code class="python" data-line-numbers>
# Creamos una serie a partir de un diccionario
datos_ciudades = {'A Coruña': 249261, 'Lugo': 99482, 
                    'Ourense': 104891, 'Pontevedra': 83077}
# Pero damos un índice distinto al del diccionario
ciudades = pd.Series(datos_ciudades, 
            index=['Santiago', 'Lugo', 'Ourense', 'Vigo'])
print(ciudades)    
# Santiago         NaN
# Lugo         99482.0
# Ourense     104891.0
# Vigo             NaN
# dtype: float64

pd.isnull(ciudades)     # También existe notnull()
# Santiago     True
# Lugo        False
# Ourense     False
# Vigo         True
# dtype: bool

                        </code></pre>
                        <pre style="height: 700px;" class="fragment" data-fragment-index="5"><code class="python" data-line-numbers>
print(ciudades)    
# Santiago         NaN
# Lugo         99482.0
# Ourense     104891.0
# Vigo             NaN
# dtype: float64

pd.isnull(ciudades)     # También existe notnull()
# Santiago     True
# Lugo        False
# Ourense     False
# Vigo         True
# dtype: bool




nuevos_nacimientos = pd.Series({'Ourense': 5000, 'Vigo': 5000})
print(ciudades + nuevos_nacimientos)   
# Lugo             NaN
# Ourense     109891.0
# Santiago         NaN
# Vigo             NaN
# dtype: float64

                        </code></pre>
                    </div>
                </div>
                <aside class="notes">
                    Si sumas dos series que tienen distinto índice, el índice del resultado es la unión de los índices
                    de los operandos.
                    Si uno de los dos operandos no tiene una cierta etiqueta en su índice, el resultado será NaN.
                </aside>
            </section>
            <section style="display: flex; flex-direction: column; align-items: left; gap: 2rem;" data-auto-animate>
                <h2>DataFrames</h2>
                <div>
                    <div>
                        <img src="media/6/series_to_dataframe.png">
                    </div>
                </div>
            </section>
            <section style="display: flex; flex-direction: column; align-items: left; gap: 2rem;" data-auto-animate>
                <h2>DataFrames</h2>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 2rem;">
                    <div style="flex: 2; text-align: left;">
                        <img src="media/6/series_to_dataframe.png">
                    </div>
                    <div style="flex: 2; text-align: left;">
                        <img src="media/6/dataframe_structure.png">
                    </div>
                </div>
            </section>
            <section style="display: flex; flex-direction: column; align-items: left; gap: 2rem;">
                <h2>DataFrames</h2>
                <ul>
                    <li>Un DataFrame representa una tabla de datos y contiene una colección ordenada de columnas, que
                        pueden tener distintos tipos de datos.</li>
                    <li class="fragment">Un DataFrame tiene dos índices: el de filas y el de columnas.</li>
                    <li class="fragment">Existen diferentes formas de crear un DataFrame.</li>
                </ul>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 0.1rem;">
                    <div style="flex: 1; text-align: center; max-width: 33%;">
                        <p>Desde un diccionario de listas/arrays de NumPy</p>
                        <pre><code class="python" data-line-numbers>
datos = {
    'nombre': ["Marcos", "Eva", "Xoel"],
    'edad': [40, 35, 23],
    'tiene_perro': [False, True, True]}
# columns permite reordenar las columnas
# Si no se encuentran los datos para 
# alguna columna, sus valores son NaNs
df=pd.DataFrame(datos, columns=['nombre', 
        'tiene_perro', 'sueldo', 'edad'])
print(df)
#    nombre  tiene_perro sueldo  edad
# 0  Marcos        False    NaN    40
# 1     Eva         True    NaN    35
# 2    Xoel         True    NaN    23
                        </code></pre>
                    </div>
                    <div style="flex: 1; text-align: center; max-width: 33%;">
                        <p>Desde una lista/array de diccionarios</p>
                        <pre><code class="python" data-line-numbers>
datos2 = [
    {'nombre': "Marcos", 'edad': 40, 
                'tiene_perro': False},
    {'nombre': "Eva", 'edad': 35, 
                'tiene_perro': True},
    {'nombre': "Xoel", 'edad': 23, 
                'tiene_perro': True}
]
df2 = pd.DataFrame(datos2)
print(df2)
#    nombre  edad  tiene_perro
# 0  Marcos    40        False
# 1     Eva    35         True
# 2    Xoel    23         True
                        </code></pre>
                    </div>
                    <div style="flex: 1; text-align: center; max-width: 33%;">
                        <p>Desde archivos<br>(CSV, Excel, JSON...)</p>
                        <pre><code class="python" data-line-numbers>
# Desde un archivo CSV
df3=pd.read_csv('ruta/al/archivo.csv', 
  header=0,  # header en la primera línea 
  sep="\t")  # campos separados por tabs

# Desde un archivo Excel
df4=pd.read_excel('ruta/al/archivo.xlsx')

# Desde un archivo JSON
df5=pd.read_json('ruta/al/archivo.json')




                        </code></pre>
                    </div>
                </div>
                <p style="text-align: right;"><small>Nota 1: Hay más posibilidades, como a partir de <em>nested
                            dictionaries</em>.<br>
                        Nota 2: Para mostrar un DataFrame, es preferible usar <span class="monospace">df.head(n)</span> a
                        <span class="monospace">print(df)</span>.<br>
                        Nota 3: <code>df.info()</code> es muy útil para comprobar, entre otros, el tipo de datos de cada columna y el número 
                        de filas y columnas.
                    </small></p>
                <aside class="notes">
                    Los índices pueden tener varios niveles (MultiIndex).
                    Al indicar columns, también se podría cambiar el index, como con Series.
                    Una vez creado un diccionario, se puede reindexar. En general, nos saltaremos bastante cosas de los
                    índices.
                </aside>
            </section>
            <section>
                <h2>Selección de datos</h2>
                <div style="display: flex;  gap: 2rem;">
                    <div
                        style="flex: 1; display: flex; text-align: left; flex-direction: column; gap:2rem; align-items: flex-start;">
                        <p>Podemos seleccionar columnas específicas a través<br> de su nombre,
                            con dos posibilidades:
                        <pre><code class="python" data-line-numbers>
columna_nombre = df['nombre']     
columna_nombre = df.nombre      # Mismo resultado que df['nombre']
print(columna_nombre)
# 0    Marcos
# 1       Eva
# 2      Xoel
# Name: nombre, dtype: object
print(type(columna_nombre))     # class 'pandas.core.series.Series'

                    </code></pre>
                    </div>
                    <div style="flex: 1; display: flex; text-align: left; flex-direction: column; gap:2rem;">
                        <p>Y también podemos seleccionar varias columnas a la vez:</p>
                        <pre><code class="python" data-line-numbers>
filtrado = df[['nombre', 'edad']]
print(filtrado)
#    nombre  edad
# 0  Marcos    40
# 1     Eva    35
# 2    Xoel    23

                </code></pre>
                    </div>
                </div>
            </section>
            <section>
                <h2>Selección de datos</h2>
                <div style="display: flex;">
                    <div style="flex: 1;">
                            <p>Para seleccionar filas y filtrar según una condición, podemos usar la
                                misma notación que con series:
                            <pre><code class="python" data-line-numbers>
print(df[:2])
#    nombre  edad  tiene_perro
# 0  Marcos    40        False
# 1     Eva    35         True

# "and" y "or" no funcionan, como en NumPy
filtrado = df[(df['edad'] < 30) | (df['nombre'] == "Marcos")]     
print(filtrado)
#    nombre  edad  tiene_perro
# 0  Marcos    40        False
# 2    Xoel    23         True
                        </code></pre>
                        </div>
                    </div>
            </section>
            <section>
                <h2>Selección de datos</h2>
                        <div style="flex: 1;  text-align: left; ">
                            <p>Para seleccionar por filas y columnas a la vez, se puede usar
                                <span class="monospace">loc[]</span>, al que se le deben pasar etiquetas, o
                                <span class="monospace">iloc[]</span>, al que se le debe pasar la posición de la
                                fila/columna como un entero.
                            </p>
                            <pre><code class="python" data-line-numbers>
print(df.loc[:, 'tiene_perro'])     # Todas las filas, columna 'tiene_perro'
# 0    False
# 1     True
# 2     True
# Name: tiene_perro, dtype: bool

print(df.iloc[1:, 1])               # Filas de 1 en adelante, primera columna
# 1     Eva
# 2    Xoel
# Name: nombre, dtype: object

print(df.iloc[1:, 1][df['edad'] < 28])    # Filtrado después de indexar
# 2    23
# Name: edad, dtype: int64
                    </code></pre>
                    </div>
                <aside class="notes">
                    También se pueden seleccionar varias filas/columnas individuales e.g. df.iloc[1, [0, 2]]
                </aside>
            </section>
            <section>
                <h2>Operaciones aritméticas con DataFrames</h2>
                <p>Muy similares a las de las series, pero alineando los datos tanto por fila como por columna.</p>
                <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
df1 = pd.DataFrame(np.arange(12).reshape((4, 3)), columns=['c1', 'c2', 'c3'], index=['r1', 'r2', 'r3', 'r4'])
df2 = pd.DataFrame(np.full((4, 4), 100), columns=['c1', 'c2', 'c4', 'c5'], index=['r1', 'r2', 'r4', 'r5'])

print(df1)
#     c1  c2  c3
# r1   0   1   2
# r2   3   4   5
# r3   6   7   8
# r4   9  10  11

print(df2)
#      c1   c2   c4   c5
# r1  100  100  100  100
# r2  100  100  100  100
# r4  100  100  100  100
# r5  100  100  100  100

print(df1 + df2)
#        c1     c2  c3  c4  c5
# r1  100.0  101.0 NaN NaN NaN
# r2  103.0  104.0 NaN NaN NaN
# r3    NaN    NaN NaN NaN NaN
# r4  109.0  110.0 NaN NaN NaN
# r5    NaN    NaN NaN NaN NaN
                </code></pre>
            </section>
            <section>
                <h2>Operaciones de reshaping</h2>
                <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 2rem;">
                    <div style="flex: 4; text-align: left; font-size: 75%;">
                        <ul>
                            <li>Ordenar las filas en función de los valores de una columna (por defecto, orden
                                ascendente, i.e., <span class="monospace">ascending=True</span>): <span
                                class="monospace">df.sort_values('col1', ascending=False)</span></li>
                            <li>Ordenar las filas en función de los valores de varias columnas (por defecto, orden
                                ascendente, i.e., <span class="monospace">ascending=True</span>): <span
                                class="monospace">df.sort_values(['col1', 'col2'], ascending=False)</span></li>
                            <li>Ordenar las filas en función del índice (por defecto, orden
                                ascendente, i.e., <span class="monospace">ascending=True</span>): <span
                                    class="monospace">df.sort_index()</span>, 
                                    <span class="monospace">df.sort_index(ascending=False)</span></li>
                            <li>Construir un nuevo índice donde las etiquetas enumeran las filas: 
                                <span class="monospace">df.reset_index()</span>. <br>Nota: el antiguo índice pasa a ser una columna.</li>
                            <li>Construir un nuevo índice donde las etiquetas enumeran las filas y eliminar el antiguo índice: 
                                <span class="monospace">df.reset_index(drop=True)</span></li>
                            <li>Añadir una nueva columna con nombre 'nueva_col': <span class="monospace">df['nueva_col'] = ...</span></li>
                            <li>Borrar columnas: <span class="monospace">df.drop(columns=['col1', 'col2'])</span></li>
                            <li>Borrar filas a partir de su etiqueta en el índice (en este ejemplo, las filas de etiquetas 0 y 1): 
                                <span class="monospace">df.drop([0, 1])</</li>
                        </ul>
                        <p><small>Estas operaciones, al igual que la mayoría de métodos de Pandas, devuelven DataFrames. Por tanto, pueden 
                            encadenarse, e.g. <span class="monospace">df.sort_values('col1').reset_index(drop=True)</span>
                        </small></p>
                    </div>

                    <div style="flex: 5; display: flex; justify-content: space-around; flex-wrap: wrap; gap: 1rem; flex-direction: row;">
                        <div>
                        <pre style="width: 500px; height: 850px;"><code class="python" data-line-numbers style="max-height: fit-content; font-size: 70%;" data-line-numbers>
# Crear un DataFrame de ejemplo
datos = {
    'col1': [3, 1, 4, 1, 5],
    'col2': [9, 2, 6, 5, 3],
    'col3': ['a', 'b', 'c', 'd', 'e']
}
df = pd.DataFrame(datos)
print(df)
#    col1  col2  col3
# 0     3     9     a
# 1     1     2     b
# 2     4     6     c
# 3     1     5     d
# 4     5     3     e

# Ordenar por col1 y col2 en orden ascendente
df_sorted = df.sort_values(['col1', 'col2'])
print(df_sorted)
#    col1  col2  col3
# 1     1     2     b
# 3     1     5     d
# 0     3     9     a
# 2     4     6     c
# 4     5     3     e

                            </code></pre></div>
                            <div><pre style="width: 500px; height: 850px;"><code class="python" data-line-numbers style="max-height: fit-content; font-size: 70%;" data-line-numbers>
# Ordenar por índice en orden descendente
df_sorted_index = df.sort_index(ascending=False)
print(df_sorted_index)
#    col1  col2  col3
# 4     5     3     e
# 3     1     5     d
# 2     4     6     c
# 1     1     2     b
# 0     3     9     a

# Resetear el índice
df_reset = df.reset_index()
print(df_reset)
#    index  col1  col2  col3
# 0      0     3     9     a
# 1      1     1     2     b
# 2      2     4     6     c
# 3      3     1     5     d
# 4      4     5     3     e

# Añadir una nueva columna
df['nueva_col'] = df['col1'] + df['col2']
print(df)
#    col1  col2  col3  nueva_col
# 0     3     9     a         12
# 1     1     2     b          3
# 2     4     6     c         10
# 3     1     5     d          6
# 4     5     3     e          8

                            </code></pre></div>
                    </div>
                    <aside class="notes">
                        Ascending = True <-> Low to high.
                    </aside>
            </section>
            <section>
                <h2>Operaciones de reshaping</h2>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 2rem;">
                    <div style="display: flex; text-align: left; flex-direction: column; gap:2rem; align-items: flex-start;">
                        <p style="margin: 0;"><span class="monospace">df.pivot()</span> convierte los datos de formato largo a ancho.</p>
                        <img src="media/6/pivot_df.png">
                    </div>
                    <div style="display: flex; text-align: left; flex-direction: column; gap:2rem;">
                        <p style="margin: 0"><span class="monospace">df.melt()</span> convierte los datos de formato ancho a largo.</p>
                        <img src="media/6/melt_df.png">
                    </div>
                </div>
            </section>
            <section>
                <h2>Transformación de datos</h2>
                <p>La función <span class="monospace">apply()</span> permite aplicar una función a lo largo de un eje de un DataFrame o 
                de los elementos de una serie.</p>
                <ul>
                    <li><span class="monospace">axis=0</span>: aplica la función a cada columna. Es la opción por defecto.</li>
                    <li><span class="monospace">axis=1</span>: aplica la función a cada fila.</li>
                </ul>
                <pre><code>
df = pd.DataFrame({
    'producto': ['A', 'B', 'C'],
    'precio': [10, 20, 30]
})
df['precio_ajustado'] = df.apply(lambda row: row['precio'] * 1.10, axis=1)
print(df)
#   producto  precio  precio_ajustado
# 0        A      10             11.0
# 1        B      20             22.0
# 2        C      30             33.0
                </code></pre>
                <aside class="notes">
                    También es posible hacer un loop sobre las filas: iterrows()
                </aside>
            </section>
            <section style="display: flex; flex-direction: column; justify-content: space-between;">
                <div style="display: flex; gap: 2rem; align-items: flex-start;">
                    <h2>Limpieza de datos</h2>
                    <span style="text-align: left;">
                        En los proyectos de análisis de datos es muy común encontrar datos faltantes (NaNs), errores de
                        medición,
                        datos duplicados, etc. Es importante saber limpiarlos de forma adecuada.
                    </span>
                </div>
                <div class="r-stack"">
                    <div style=" display:flex; flex-direction: column; text-align: left;"
                    class="fragment current-visible">
                    <p>Existen varios métodos de utilidad:</p>
                    <div>
                        <ul>
                            <li><span class="monospace">dropna()</span>: Elimina todas las filas y columnas que
                                contienen NAs</li>
                        </ul>

                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
    datos = pd.DataFrame([[1., 6.5, 2.], 
                          [1., np.nan, np.nan], 
                          [np.nan, np.nan, np.nan], 
                          [np.nan, 6.5, 3.]])
    datos_limpios = datos.dropna()  
    
    print(datos)
    #      0    1    2
    # 0  1.0  6.5  2.0
    # 1  1.0  NaN  NaN
    # 2  NaN  NaN  NaN
    # 3  NaN  6.5  3.0
    print(datos_limpios)
    #      0    1    2
    # 0  1.0  6.5  2.0
                        </code></pre>
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <ul>
                            <li><span class="monospace">dropna(how="all")</span>: Elimina solo las filas en las que
                                todos los datos son NAs</li>
                            <li><span class="monospace">dropna(how="all", axis=1)</span>: Elimina solo las columnas
                                en las que todos los datos son NAs</li>
                        </ul>

                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
datos = pd.DataFrame([[1., 6.5, 2.], 
                      [1., np.nan, np.nan], 
                      [np.nan, np.nan, np.nan], 
                      [np.nan, 6.5, 3.]])
datos_limpios = datos.dropna(how="all")  

print(datos)
#      0    1    2
# 0  1.0  6.5  2.0
# 1  1.0  NaN  NaN
# 2  NaN  NaN  NaN
# 3  NaN  6.5  3.0
print(datos_limpios)
#      0    1    2
# 0  1.0  6.5  2.0
# 1  1.0  NaN  NaN
# 3  NaN  6.5  3.0
                        </code></pre>
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <p>Es común usar DataFrames para guardar datos recogidos a lo largo del tiempo. Cada columna
                            corresponde a los
                            atributos de interés y cada fila, a los datos recogidos en un instante de tiempo. En tal
                            caso, se puede elegir
                            eliminar aquellas filas que no tienen un número de mediciones suficientes.</p>
                        <ul>
                            <li><span class="monospace">dropna(thresh=n)</span>: Elimina las filas que no tienen al
                                menos $n$ valores no NAs</li>
                        </ul>

                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" data-line-numbers>
datos = pd.DataFrame([[1., 6.5, 2.], [1., np.nan, np.nan], [np.nan, np.nan, np.nan], [np.nan, 6.5, 3.]])
datos_limpios = datos.dropna(thresh=2)  

print(datos)
#      0    1    2
# 0  1.0  6.5  2.0
# 1  1.0  NaN  NaN
# 2  NaN  NaN  NaN
# 3  NaN  6.5  3.0
print(datos_limpios)
#      0    1    2
# 0  1.0  6.5  2.0
# 3  NaN  6.5  3.0
                        </code></pre>
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <p>En lugar de eliminar los valores faltantes, podemos optar por rellenar sus posiciones con
                            un determinado valor.</p>
                        <ul>
                            <li><span class="monospace">fillna()</span>: Sustituye los NAs por el valor pasado como
                                argumento.</li>
                        </ul>

                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
datos = pd.DataFrame([[1., 6.5, 2.], [1., np.nan, np.nan], [np.nan, np.nan, np.nan], [np.nan, 6.5, 3.]])
datos_limpios = datos.fillna(0) 
datos_limpios_2 = datos.fillna(datos.mean())    # También admite otras estructuras de datos

print(datos)
#      0    1    2
# 0  1.0  6.5  2.0
# 1  1.0  NaN  NaN
# 2  NaN  NaN  NaN
# 3  NaN  6.5  3.0
print(datos_limpios);                        print(datos_limpios_2)
#      0    1    2                                  0    1    2         
# 0  1.0  6.5  2.0                             0  1.0  6.5  2.0 
# 1  1.0  0.0  0.0                             1  1.0  6.5  2.5
# 2  0.0  0.0  0.0                             2  1.0  6.5  2.5
# 3  0.0  6.5  3.0                             3  1.0  6.5  3.0

                        </code></pre>
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <p>También es importante localizar y eliminar filas duplicadas cuando tiene sentido hacerlo.</p>
                        <ul>
                            <li><span class="monospace">duplicated()</span>: Devuelve una serie indicando, para cada
                                fila, si está duplicada o no.</li>
                            <li><span class="monospace">drop_duplicates()</span>: Elimina las filas duplicadas.</li>
                            <li>A ambos métodos se les pueden indicar solo columnas concretas.</li>
                        </ul>
                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
df = pd.DataFrame({'c1': ['a'] * 3 + ['b'] * 2,
                   'c2': [1, 1, 2, 3, 3]})

print(df);                             print(df.duplicated())
#   c1  c2                             
# 0  a   1                             0    False
# 1  a   1                             1     True
# 2  a   2                             2    False
# 3  b   3                             3    False
# 4  b   3                             4     True
#                                      dtype: bool

print(df.drop_duplicates());           print(df.drop_duplicates().reset_index(drop=True))
#   c1  c2                                c1  c2 
# 0  a   1                             0  a   1
# 2  a   2                             1  a   2
# 3  b   3                             2  b   3

                        </code></pre>
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment">
                    <div style="font-size: 70%;">
                        <p>Los <em>outliers</em> pueden deberse a errores de medición o de inserción en la bases de
                            datos.
                            En estos casos, es recomendable eliminarlos.</p>
                        <p>Hay diferentes opciones: eliminarlos, sustituirlos por el máximo/por la media, etc.</p>
                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
datos_ph = pd.DataFrame(16 * np.random.rand(1000, 4), columns=["detector1", "detector2", "detector3", "detector4"])
print(datos_ph.describe())
#          detector1    detector2    detector3    detector4
# count  1000.000000  1000.000000  1000.000000  1000.000000
# mean      8.008337     8.267079     7.916209     8.024089
# std       4.722665     4.585955     4.644795     4.587050
# min       0.023579     0.070377     0.020743     0.004057
# 25%       3.812108     4.474951     3.877351     4.281892
# 50%       8.007732     8.042149     7.647697     7.886486
# 75%      12.133669    12.261288    12.005321    11.885338
# max      15.988374    15.999366    15.986327    15.979152

datos_ph[datos_ph > 14] = 14
print(datos_ph.describe())
#          detector1    detector2    detector3    detector4
# count  1000.000000  1000.000000  1000.000000  1000.000000
# mean      7.875772     7.881265     7.894457     7.947086
# std       4.457306     4.422518     4.379599     4.390199
# min       0.036536     0.026266     0.001390     0.008563
# 25%       3.836448     4.154702     4.154869     4.094805
# 50%       8.132162     7.936885     7.928288     7.960573
# 75%      12.143415    12.058752    11.999224    12.138702
# max      14.000000    14.000000    14.000000    14.000000
                        </code></pre>
                    </div>
                </div>
        </div>
        <aside class="notes">
            En un proyecto de análisis de datos, el 80% del tiempo suele dedicarse a limpiar y transformar
            los datos.
            Solo el 20% restante se dedica verdaderamente a analizar los datos (80/20 rule).
        </aside>
        </section>
        <section style="display: flex; flex-direction: row; align-items: left; gap: 2rem;">
            <h2>Análisis estadísticos</h2>
            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 2rem;">
                <div style="flex: 2; text-align: left;">
                    <ul>
                        <li>Resumen de los datos numéricos (media, std, min, max, percentiles): <span
                                class="monospace">describe()</span></li>
                        <li class="fragment">Medidas de centralización: <span class="monospace">mean()</span>, <span
                                class="monospace">median()</span>, <span class="monospace">mode()</span></li>
                        <li class="fragment">Medidas de dispersión: <span class="monospace">std()</span>, <span
                                class="monospace">var()</span>, <span class="monospace">mad()</span></li>
                        <li class="fragment">Medidas de posición relativa: <span class="monospace">quantile(q)</span>,
                            <span class="monospace">min()</span>, <span class="monospace">max()</span>
                        </li>
                        <li class="fragment">Otras: <span class="monospace">sum()</span>, <span
                                class="monospace">count()</span> - cuenta el número de valores no nulos, 
                            <span class="monospace">value_counts()</span> - cuenta el número de filas distintas, etc.</li>
                        <li class="fragment"><span class="monospace">corr()</span> calcula la correlación entre
                            columnas (de Pearson, Spearman o Kendall)</li>
                        <li class="fragment"><span class="monospace">cov()</span> calcula la matriz de covarianzas
                        </li>
                    </ul>
                    <p class="fragment">Otras librerías, como <span class="monospace">scipy</span>, permiten
                        realizar operaciones más
                        avanzadas, como contrastes de hipótesis.</p>
                </div>

                <div style="flex: 2;">
                    <pre><code class="python" data-line-numbers style="max-height: fit-content;" data-line-numbers>
df = pd.DataFrame({
    "A": [1, 2, 3, 4, 5],
    "B": [2, 4, 6, 8, 10],
    "C": [np.nan, 3, 8, 6, 7]
})

print(df.describe())
#               A          B         C
# count  5.000000   5.000000  4.000000
# mean   3.000000   6.000000  6.000000
# std    1.581139   3.162278  2.160247
# min    1.000000   2.000000  3.000000
# 25%    2.000000   4.000000  5.250000
# 50%    3.000000   6.000000  6.500000
# 75%    4.000000   8.000000  7.250000
# max    5.000000  10.000000  8.000000

print(df.corr())   
#           A         B         C
# A  1.000000  1.000000  0.597614
# B  1.000000  1.000000  0.597614
# C  0.597614  0.597614  1.000000

                        </code></pre>
                </div>
                <aside class="notes">
                    Las medidas se pueden calcular en global o sobre columnas específicas.
                </aside>
        </section>
        <section>
            <div style="display: flex; gap: 2rem; align-items: flex-start;">
                <h2>Combinación de datasets</h2>
                <span style="text-align: left;">
                    En muchas ocasiones, los datos de un proyecto están en archivos o formatos distintos. Para poder
                    utilizarlos, es conveniente combinarlos en una única estructura de datos.
                </span>
            </div>
            <div class="r-stack">
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <ul>
                            <li><span class="monospace">merge()</span>: Combinación de filas de datasets en base a
                                una o más columnas comunes (producto cartesiano).</li>
                            <li>Por defecto, <span class="monospace">merge()</span> los combina en base a las
                                columnas que tienen el mismo nombre.
                                Se pueden indicar explícitamente
                                con el argumento <span class="monospace">on</span>. <br>Ejemplo: <span
                                    class="monospace"> pd.merge(df1, df2,
                                    on=["col_comun_1", "col_comun_2"])</span>
                            </li>
                            <li>Si la columna común tiene un nombre distinto en cada dataframe, se pueden
                                referenciar por separado:
                                <span class="monospace">pd.merge(df_left, df_right, left_on="left_col",
                                    right_on="right_col")</span>
                            </li>
                        </ul>
                    </div>

                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <img src="media/6/merge_df.png" style="height: 450px;">
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <ul>
                            <li><span class="monospace">merge()</span>: Combinación de filas de datasets en base a
                                una o más columnas comunes (producto cartesiano).</li>
                            <li>Por defecto, <span class="monospace">merge()</span> los combina en base a las
                                columnas que tienen el mismo nombre.
                                Se pueden indicar explícitamente
                                con el argumento <span class="monospace">on</span>. <br>Ejemplo: <span
                                    class="monospace"> pd.merge(df1, df2,
                                    on=["col_comun_1", "col_comun_2"])</span>
                            </li>
                            <li>Si la columna común tiene un nombre distinto en cada dataframe, se pueden
                                referenciar por separado:
                                <span class="monospace">pd.merge(df_left, df_right, left_on="left_col",
                                    right_on="right_col")</span>
                            </li>
                        </ul>
                    </div>

                    <div style="display: flex; flex-direction: row;">
                        <pre><code class="python" data-line-numbers>
df1 = pd.DataFrame({"frutas": ["manzanas", "platanos", "limones", "uvas", "manzanas"], 
        "unidades": np.random.randint(1, 10, 5)})   # 5 enteros aleatorios en el intervalo [1, 10)
df2 = pd.DataFrame({"frutas": ["manzanas", "platanos", "limones", "uvas"],
        "precio": np.random.random(4) * 10})        # (4 floats aleatorios en el intervalo [0, 1)) * 10

print(pd.merge(df1, df2))          
#      frutas  unidades    precio
# 0  manzanas         5  5.630322
# 1  manzanas         4  5.630322
# 2  platanos         7  4.570918
# 3   limones         6  3.348530
# 4      uvas         8  6.413218

# Equivalentes: pd.merge(df1, df2, on="frutas"), pd.merge(df1, df2, left_on="frutas", right_on="frutas")

                        </code></pre>
                    </div>
                </div>

                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div style="font-size: 75%;">
                        <ul>
                            <li>¿Qué pasa si alguno de los DataFrames no tiene datos para todos los valores de la
                                columna común?</li>
                            <li>Por defecto, en el resultado de <span class="monospace">merge()</span> solo
                                aparecerán aquellos valores que están en ambos DataFrames. Es decir, se hace una
                                intersección sobre la columna ("inner join").
                            </li>
                            <li>Con el parámetro <span class="monospace">how</span> podemos controlar este
                                comportamiento.</li>
                            <li><span class="monospace">how="outer"</span>: toma la unión de los valores y rellena
                                con NaNs.</li>
                            <li><span class="monospace">how="left"</span>: toma solo los valores de la columna del
                                primer DataFrame. Si alguno no aparece
                                en el segundo DataFrame, rellena con NaNs. <span class="monospace">how="right"</span> es
                                análogo.</li>
                        </ul>
                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
df1 = pd.DataFrame({"frutas": ["manzanas", "platanos", "limones"], 
        "unidades": np.random.randint(1, 10, 3)})     # 3 enteros aleatorios en el intervalo [1, 10)
df2 = pd.DataFrame({"frutas": ["manzanas", "platanos", "uvas"],
        "precio": np.random.random(3) * 10})          # (3 floats aleatorios en el intervalo [0, 1)) * 10

print(pd.merge(df1, df2))          
#      frutas  unidades    precio
# 0  manzanas         4  6.482856
# 1  platanos         1  1.942549

print(pd.merge(df1, df2, how="outer"))
#       frutas  unidades    precio
#  0  manzanas       1.0  3.814989
#  1  platanos       8.0  1.374147
#  2   limones       9.0       NaN
#  3      uvas       NaN  7.856911
                        </code></pre>
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment current-visible">
                    <div>
                        <ul>
                            <li><span class="monospace">concat()</span>: Concatena dos DataFrames a lo largo de las
                                filas (axis = 0) o de las columnas (axis=1).</li>
                            <li>Lo más común es querer descartar los índices originales. Para ello, hay que usar indicar
                                <span class="monospace">ignore_index=True</span> como parámetro.
                            </li>
                            <li>Nota: NumPy tiene una función análoga para concatenar arrays.</li>
                        </ul>
                    </div>

                    <div style="display: flex; flex-direction: column; align-items: center;">
                        <img src="media/6/concat_df.png" height="605px">
                    </div>
                </div>
                <div style="display:flex; flex-direction: column; text-align: left;" class="fragment">
                    <div>
                        <ul>
                            <li><span class="monospace">concat()</span>: Concatena dos DataFrames a lo largo de las
                                filas (axis = 0) o de las columnas (axis=1).</li>
                            <li>Lo más común es querer descartar los índices originales. Para ello, hay que usar indicar
                                <span class="monospace">ignore_index=True</span> como parámetro.
                            </li>
                            <li>Nota: NumPy tiene una función análoga para concatenar arrays.</li>
                        </ul>
                    </div>

                    <div
                        style="display: flex; flex-direction: row; align-items: flex-start; margin-top: 2rem; gap:2rem; justify-content: space-between;">
                        <pre><code class="python" style="max-height: fit-content;" data-line-numbers>
df1 = pd.DataFrame({
        "A": ["A0", "A1", "A2", "A3"],
        "B": ["B0", "B1", "B2", "B3"]})

df2 = pd.DataFrame({
        "A": ["A4", "A5", "A6", "A7"],
        "B": ["B4", "B5", "B6", "B7"]})

print(pd.concat([df1, df2]));                   print(pd.concat([df1, df2], ignore_index=True))
#      A   B                                          A   B   
#  0  A0  B0                                      0  A0  B0 
#  1  A1  B1                                      1  A1  B1 
#  2  A2  B2                                      2  A2  B2 
#  3  A3  B3                                      3  A3  B3 
#  0  A4  B4                                      4  A4  B4 
#  1  A5  B5                                      5  A5  B5 
#  2  A6  B6                                      6  A6  B6 
#  3  A7  B7                                      7  A7  B7 

                            </code></pre>
                    </div>
                </div>
            </div>
            <aside class="notes">
                El manejo de los NaNs es bastante complicado. La operación de merge es compleja. how="inner",
                "outer", "left", "right".
                Los índices de los DataFrames originales se descartan.
                Cuidado con columnas que se llamen igual y que no queramos mergear! (suffixes)
                También se puede mergear sobre el índice en lugar de sobre una columna: left_index=True o
                right_index=True
            </aside>
        </section>
        <section>
            <div style="display: flex; gap: 2rem; align-items: flex-start;">
                <h2>Agrupación de datos</h2>
                <span style="text-align: left;">
                    La operación de <span class="monospace">groupby()</span> permite agrupar los datos en función a valores comunes de 
                    una variable y realizar alguna operación sobre ellos: sumarlos, tomar el máximo/mínimo, hacer la media, etc.
                </span>
            </div>
            <div class="r-stack">
                <div style="display: flex; flex-direction: column; align-items: center;" class="fragment current-visible">
                    <img src="media/6/group_df.png" style="height: 800px;">
                </div>
                <div class="fragment">
                    <pre style="width: 1500px;"><code class="python" style="max-height: fit-content;" data-line-numbers>
df = pd.DataFrame({
    "estudiante": ["Laura", "David", "Víctor", "Laura", "David", "Víctor"],
    "asignatura": ["ANM", "EDO", "TGS", "ANM", "TGS", "EDO"],
    "nota": [0.5, 6.0, 9.2, 1.1, 5.0, 10]
})
print(df)
#   estudiante asignatura  nota
# 0      Laura        ANM   0.5
# 1      David        EDO   6.0
# 2     Víctor        TGS   9.2
# 3      Laura        ANM   1.1
# 4      David        TGS   5.0
# 5     Víctor        EDO  10.0

print(df[["estudiante", "nota"]].groupby("estudiante").mean())
#             nota
# estudiante      
# David        5.5
# Laura        0.8
# Víctor       9.6

                    </code></pre>
                </div>
            </div>
        </section>
        <section>
            <h2>¡Hora de practicar!</h2>
            <div style="align-items: center; justify-content: center; display:flex; flex-direction: column;">
                <p style="width: 60%;">Para fijar ideas, exploraremos el <a href="https://www.kaggle.com/datasets/omarhanyy/imdb-top-1000">siguiente dataset</a> conteniendo información de las $1000$ películas de la historia según <a href="">IMDB</a>.</p>
                <div style="border: 2px solid gray; padding: 1rem; border-radius: 10px; width: 60%;">
                    <p>
                        <a href="notebooks/imdb_analysis.ipynb" download>Notebook - Análisis de datos de películas con Pandas</a>
                    </p>
                    <p>
                        <a href="data/imdb_top_1000.csv" download>Dataset de películas (descarga directa)</a>
                    </p>
                    <p>
                        <a href="notebooks/imdb_analysis_solutions.ipynb" download>Soluciones del notebook</a>
                    </p>
                </div>
            </div>
        </section>
    </div>
    </div>

    <script src="dist/reveal.js"></script>
    <script src="plugin/notes/notes.js"></script>
    <script src="plugin/math/math.js"></script>
    <script src="plugin/markdown/markdown.js"></script>
    <script src="plugin/highlight/highlight.js"></script>
    <script>
        // More info about initialization & config:
        // - https://revealjs.com/initialization/
        // - https://revealjs.com/config/
        Reveal.initialize({
            hash: true,
            katex: {
                version: 'latest',
                delimiters: [
                    { left: '$$', right: '$$', display: true },
                    { left: '$', right: '$', display: false },
                    { left: '\\(', right: '\\)', display: false },
                    { left: '\\[', right: '\\]', display: true },
                ],
                ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            },
            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
        });
    </script>
    <script src="theme-toggle.js"></script>
</body>

</html>