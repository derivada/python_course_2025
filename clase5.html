<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <title>Clase 5</title>

  <link rel="stylesheet" href="dist/reset.css">
  <link rel="stylesheet" href="dist/reveal.css">
  <link rel="stylesheet" href="common.css">
  <!-- Solarized theme -->
  <link id="light-theme" rel="stylesheet" href="dist/theme/solarized.css">
  <!-- Moon theme -->
  <link id="dark-theme" rel="stylesheet" href="dist/theme/moon.css" disabled>

  <link rel="stylesheet" href="plugin/highlight/atom-one-dark.css">
</head>

<body data-theme="light">
  <a href="index.html" class="back-link">Volver</a>
  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle theme">
    <svg class="icon sun-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
    <svg class="icon moon-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
    </svg>
  </button>
  <div class="reveal">
    <div class="slides">
      <!--TEXTO IZQUIERDA - CÓDIGO DERECHA -->
      <section data-auto-animate>
        <h1>Introducción a numpy</h1>
      </section>
      <section data-auto-animate>
        <h1><span><u>Introducción</u></span> a numpy</h1>
        <p>Solo veremos una parte muy pequeña de esta librería</p>
        <p>La documentación completa está disponible <a href="https://numpy.org/doc/stable/">aquí</a></p>
      </section>
      <section>
        <h2>Qué es numpy?</h2>
        <div style="display: flex; flex-direction: row;">
          <div style="flex: 1;">
            <img src="/media/5/numpylogo.png" style="vertical-align: middle;">
          </div>
          <div style="flex: 2; text-align: left;">
            <p class="fragment">Ya hemos hablado de las listas <span class="monospace">lista = [1, "python",
                [1,3]]</span>, que son colecciones lineales de elementos</p>
            <p class="fragment">También podemos crear matrices como listas anidadas:<br> <span class="monospace"> M =
                [[0,1], [1,0]]</span> $\;\Longleftrightarrow \; M = \begin{pmatrix}0 \;1 \\ 1 \;0 \end{pmatrix}$</p>
            <p class="fragment">Las listas son muy flexibles al admitir formas irregulares y tipos de datos heterogéneos, pero <b>esta
                flexibilidad tiene un gran coste en eficiencia.</b></p>
          </div>
        </div>
        <p class="fragment">Para remediar estos problemas, NumPy nos da una estructura de datos llamada <em>array n-dimensional (ndarray)</em></p>
        <div class="fragment" style="display: flex;">
          <div style="flex: 1; text-align: right; font-size: 2rem;">$\rightarrow$ NumPy está escrito en C y usa librerías de álgebra lineal de alto rendimiento como BLAS y LAPACK, lo cuál hace que los <span class="monospace">ndarrays</span> sean órdenes de magnitudes más rápidos que las listas</div>
          <div style="flex: 1;"><img src="media/5/numpy-arch.png" height="300px"></div>
        </div>
      </section>
      <section style="display: flex; flex-direction: column; align-items: left; gap: 2rem;">
        <h3>ndarrays</h3>
        <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 2rem;">
            <div style="flex: 2; text-align: left;">
                <ul>
                    <li>Tienen un tamaño fijo, fijado en su creación</li>
                    <li>Todos sus elementos son del mismo tipo (normalmente numéricos)</li>
                    <li>Se pueden indexar de muchas formas, y NumPy provee cientos de operaciones <b>vectorizadas</b> sobre ellos</li>
                    <li>Son similares a los vectores de R y de MATLAB, aunque hay ciertas diferencias</li>
                </ul>
            </div>
            <div style="flex: 2; text-align: left;">
                <pre><code class="python" data-line-numbers>
import numpy as np
a = np.arange(16).reshape(4,4)
print(a)  # array([[ 0,  1,  2,  3],
          #        [ 4,  5,  6,  7],
          #        [ 8,  9, 10, 11],
          #        [12, 13, 14, 15]])
print(a.ndim)   # 2
print(a.shape)  # (4, 4)
print(a.size)   # 16
print(a.dtype)  # int64
                </code></pre>
            </div>
        </div>
        <div class="fragment">
          <div style="margin:1rem; padding:1rem; border: 2px solid; border-radius:10px;">Hay 4 atributos fundamentales que describen la estructura del ndarray</div>
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 2rem;">
              <div><span class="monospace">ndarray.ndim</span><br> Número de dimensiones</div>
              <div><span class="monospace">ndarray.shape</span><br>Número de elementos en cada dimensión (tupla)</div>
              <div><span class="monospace">ndarray.size</span><br>Número total de elementos</div>
              <div><span class="monospace">ndarray.dtype</span><br>El tipo de dato de los elementos</div>
          </div>
        </div>
    </section>
    <section>
      <div>
        <h3>ndarray: orden de los ejes</h3>
        <p>Al haber varias dimensiones, tenemos que tener en cuenta el orden de acceso e impresión de elementos. Para arrays en 2 dimensiones, el primer eje <span>axis = 0</span> son las filas, y el segundo <span>axis = 1</span> las columnas</p>
        <pre><code class="python" data-line-numbers>
  a = np.array([[2., 3., 5.],
                [7., 8., 9.]])
        </code></pre>
        el primer eje es de tamaño $2$ y el segundo de tamaño $3$.
        <p>Para $n > 2$, ya no se pueden visualizar los ndarrays como matrices, pero podemos seguir consultando el tamaño de cada eje con <span class="monospace">np.shape</span>.</p>
        <img src="media/5/anatomy_array.png">
      </section>
      <section data-auto-animate> 
        <div style="height:100%; display: flex; flex-direction: column; justify-content: space-around; gap: 2rem;">
          <div>
            <h3>Creación de arrays</h3>
            <p>Hay muchos mecanismos de creación de arrays n-dimensionales</p>
          </div>
            <div style="text-align: left;">
                <p>A partir de otras estructuras (listas y tuplas)</p>
                <pre><code class="python" data-line-numbers>
    import numpy as np
    # se puede especificar el tipo de dato
    a = np.array([1, 2, 3], dtype=float64)
    a3D = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])

                </code></pre>
            </div>
        </div>
      </section>
    <section data-auto-animate>
      <div style="height:100%; display: flex; flex-direction: column; justify-content: space-around; gap: 2rem;">
        <div>
          <h3>Creación de arrays</h3>
          <p>Hay muchos mecanismos de creación de arrays n-dimensionales</p>
        </div>
        <div style="text-align: left;">
            <p>Utilizando <span class="monospace">np.arrange</span> y <span class="monospace">np.linspace</span> para crear listas de rangos separados</p>
            <li><span class="monospace">np.arrange(start, stop, step)</span> crea un array del tipo $[start, start+step, start+2step, \dots]$.</li>
            <li>Si step es decimal, es mejor usar <span class="monospace">np.linspace(start, stop, num)</span>, que crea una rejilla regular con $num$ puntos en total.</li>
            <pre><code class="python" data-line-numbers>
  import numpy as np

  # Crear un array de 0 a 10, con salto de 2
  a = np.arange(0, 10, 2) # array([0, 2, 4, 6, 8])

  # Crear un array de 0 a pi, con 10000 elementos
  b = np.linspace(0, np.pi, 10000) # array([0.00000000e+00, 3.14190684e-04, 6.28381369e-04, ...,
                                  #        3.14096427e+00, 3.14127846e+00, 3.14159265e+00])
              </code></pre>
          </div>
        </div>
    </section>
    <section data-auto-animate>
      <div style="height:100%; display: flex; flex-direction: column; justify-content: space-around; gap: 2rem;">
        <div>
          <h3>Creación de arrays</h3>
          <p>Hay muchos mecanismos de creación de arrays n-dimensionales</p>
        </div>
        <div style="text-align: left;">
          <p>Mediante funciones de creación:</p>
            <li><span class="monospace">np.zeros()</span> y <span class="monospace">np.ones()</span> para arrays de 0s y 1s</li>
            <li><span class="monospace">np.eye()</span> para la matriz identidad</li>
            <li><span class="monospace">np.random()</span> para datos aleatorios</li>
            <pre><code class="python" data-line-numbers>
  import numpy as np

  # Array de ceros con shape (3,3)
  zeros = np.zeros((3, 3))
  
  # Array de unos con shape (2,4)
  ones = np.ones((2, 4))
  
  # Matriz identidad de 4x4
  id = np.eye(4)
  
  # Array aleatorio de tamaño (2,3) con valores en [0,1)
  rand_arr = np.random.rand(2, 3)
      </code></pre>
      </div>
    </section>
    <section data-auto-animate>
      <div style="height:100%; display: flex; flex-direction: column; justify-content: space-around; gap: 2rem;">
        <div>
          <h3>Creación de arrays</h3>
          <p>Hay muchos mecanismos de creación de arrays n-dimensionales</p>
        </div>
        <div style="text-align: left;">
          <li>Juntando varios arrays a través de uno de los ejes</li>
          <pre><code class="python" data-line-numbers>
import numpy as np

a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])

# Usando vstack (equivalente a np.concatenate con axis=0)
vstacked = np.vstack((a, b))  # array([[1, 2],
                              #        [3, 4],
                              #        [5, 6],
                              #        [7, 8]])

# Usando hstack (equivalente a np.concatenate con axis=1)
hstacked = np.hstack((a, b)) # array([[1, 2, 5, 6],
                             #        [3, 4, 7, 8]])
        </code></pre>
        </div>
      <p>Ya hemos visto varias formas de crear arrays, pero también es importante saber que (casi) todas las operaciones que explicaremos más adelante también crean arrays nuevos.</p>
      <small style="max-width: 800px; text-align: left;">Hay alguna otra forma más de crear arrays, por ejemplo a partir de ficheros. En la siguiente clase leeremos ficheros con Pandas, así que nos saltamos esto de momento, consultar: <a href="https://numpy.org/doc/stable/user/basics.creation.html">Array Creation guide</a></small>
    </div>
  </section>
  <section>
    <h3>Indexación y slicing</h3>
    <p>En un array de NumPy, el indexado es parecido al de una lista normal de Python, pero en varias dimensiones</p>
    <div style="display:flex; gap: 1rem;">
      <div style="flex: 1;">
        <pre><code class="python" data-line-numbers>
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# Elementos específicos
print(a[0, 0])  # 1
print(a[1, 2])  # 6

# Segunda fila
print(a[1])     # [4, 5, 6]
# Segunda columna
print(a[:, 1])  # [2, 5, 8]

# Slicing en varias dimensiones
print(a[1:, 1:])  # array([[5, 6],
                  #        [8, 9]])

        </code></pre>
        </div>
        <div style="flex: 1;">
          <img src="media/6/2d_index.png">
        </div>
      </div>
    </section>
    <section>
      <h3>Indexación y slicing</h3>
      <p>También podemos indexar a partir de otros arrays</p>
      <pre><code class="python" data-line-numbers>
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# Filas 2 y 1
b = np.array([1, 0])
print(a[b]) # array([[4, 5, 6],
            #        [1, 2, 3]])

# Todas las filas, y luego columnas 1 y 2
c = np.array([1,2])
print(a[:, c]) # array([[2, 3],
               #        [5, 6],
               #        [8, 9]])
    </code></pre>
    O a partir de arrays de booleanos, útil para implementar filtros
    <pre><code class="python" data-line-numbers>
a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
print(a[a > 5]) # array([6, 7, 8, 9])
    </code></pre>
  </section>
  <section>
    <h3>Reshaping</h3>
    <div style="display: flex; flex-direction: column; gap: 1rem;">
      <p style="font-size: 120%;">Con <span class="monospace">arr.reshape()</span> podemos cambiar la forma de un array</p>
      <div class="fragment">
        <p>
          Por ejemplo podemos pasar de un array $6 \times 2$ a uno $3 \times 4$:
        </p>
        <pre style="max-width: 1000px; max-height:200px;"><code class="python" data-line-numbers>
import numpy as np
a = np.arange(12).reshape(6, 2)
print(a.shape)  # (6, 2)
b = a.reshape(3, 4)
print(b.shape)  # (3, 4)

        </code></pre>
      </div>
      <div class="fragment">
        <p>
          Pro tip: Si no sabemos el tamaño de una de las dimensiones, podemos hacer que NumPy la calcule inmediatamente poniendo $-1$ en ella.
        </p>
        <pre style="max-width: 1000px; max-height:200px;"><code class="python" data-line-numbers>
import numpy as np
a = np.arrange(15000)
b = a.reshape(-1, 3, 1000)
print(b.shape)  # (5, 3, 1000)

        </code></pre>
      </div>
        <div style="display: flex; gap: 1rem;">
          <div class="fragment">
            <p>Con <span class="monospace">np.ravel</span> podemos linealizar un array y con <span class="monospace">arr.T</span> hallar la traspuesta de una matriz!</p>
            <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([[1, 2], [3, 4]])
print(a.ravel())  # array([1, 2, 3, 4])
print(a.T)        # array([[1, 3],
                  #        [2, 4]])

            </code></pre>
          </div>
          <div class="fragment">
            <p>También podemos añadir nuevos ejes con <span class="monospace">np.newaxis</span> o <span class="monospace">np.expand_dims</span></p>
            <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([1, 2, 3])
print(a[:, np.newaxis])  # array([[1],
                         #        [2],
                         #        [3]])

            </code></pre>
          </div>
        </div>
    </div>
  </section>
  <section>
    <h2>Operaciones sobre arrays</h2>
    <ul>
      <li class="fragment">Las operaciones sonre arrays de NumPy son <em>vectorizadas</em>, es decir, no tenemos que ir elemento por elemento aplicando los operadores.</li>
      <li class="fragment">Esto reduce tanto el número de líneas que hay que escribir como el tiempo de ejecución <a href="https://en.wikipedia.org/wiki/Single_instruction,_multiple_data">(ya que los procesadores modernos pueden realmente hacer muchas operaciones a la vez)</a></li>
    </ul>
    <div class="fragment" style="margin-top: 2rem;">
      <p>De esta forma, podemos aplicar operaciones básicas simplemente como:</p>
      <div style="display:flex; gap: 1rem; flex-direction: row;">
        <div style="flex:1;">
          <pre><code class="python" data-line-numbers>
import numpy as np
data = np.array([1, 2])
ones = np.ones(2, dtype=int)

# Operaciones aritméticas vectorizadas
print(data + ones)  # array([2, 3])
print(data - ones)  # array([0, 1])
print(data * data)  # array([1, 4])
print(data / data)  # array([1, 1])

# NO HACER ESTO
for i in range(len(data)):
    data[i] += 1

          </code></pre>
        </div>
        <div style="flex: 1; display:flex; flex-direction: column;">
          <img src="media/6/operators1.png">
          <img src="media/6/operators2.png">
        </div>
      </div>
    </div>
  </section>
  <section>
    <h2>Operaciones sobre arrays</h2>
    <p>Además de las operaciones básicas, NumPy nos proporciona cientos de funciones matemáticas que aplicar sobre arrays. Algunas de ellas están en paquetes separados, por ejemplo:</p>
    <ul class="fragment">
      <hr>
      <li><span class="monospace ">numpy.linalg</span>. Incluye funciones para álgebra lineal. Incluye resolución de sistemas lineales, cálculo de autovalores, descomposiciones SVD, de Cholesky, $\dots$ (es decir, ANM in a box)</li>
      <li><span class="random">numpy.random</span>. Incluye funciones para crear arrays aleatorios, que sigan ciertas distribuciones estadísticas.</li>
      <li><span class="monospace">numpy.fft</span>. Contiene funciones para transformadas de fourier rápidas en varias dimensiones.</li>
      <hr>
    </ul>
    <p class="fragment">También existe la librería <a href="https://scipy.org/">SciPy</a>, que no cubriremos en este curso, pero expande NumPy incorporando muchas más funciones de computación científica.</p>
  </section>
  <section>
    <h2>Operaciones sobre arrays</h2>
    <div style="display: flex; gap: 1rem;">
      <div style="flex: 1;">
        <p style="font-size: 120%;">Además de operar sobre 2 arrays, podemos <em>agregar</em> los elementos de uno mediante operadores como la suma, el máximo o el mínimo, entre muchos otros.</p>
        <img src="media/6/agg.png">
        <p style="font-size: 120%;">En vez de ejecutar esto sobre todo un array, podemos reducir en cada eje</p>
        <img src="media/6/agg_axis.png">
      </div>
      <div style="flex: 1;" data-line-numbers="1-5|7-9">
        <pre><code class="python" data-line-numbers>
import numpy as np
data = np.array([[1, 2], [3, 4]])
print(data.sum())  # 10
print(data.max())  # 4


print(data.sum(axis=0))  # array([4, 6])
print(data.max(axis=1))  # array([2, 4])
        </code></pre>
        <div class="fragment">
          <hr style="margin-top: 2rem;">
          <p>También es importante el <em>broadcasting</em>, que permite operar un array grande con otro pequeño (incluso con un escalar) "copiando" el pequeño varias veces a lo largo de un eje.</p>
          <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([1, 1, 1])
print(a + 5)    # array([6, 6, 6])

b = np.array([[1, 2, 3], [4, 5, 6]])
print(b + a)    # array([[2, 3, 4],
                #        [5, 6, 7]])

          </code></pre>
          <img src="media/6/broadcasting.png">
          <p style="font-size: 80%;">Existen algunas normas sobre cuando podemos hacer esto, se pueden consultar <a href="https://numpy.org/doc/stable/user/basics.broadcasting.html">aquí</a></p>
        </div>
      </div>
    </div>
  </section>
  <section>
    <h2>Operaciones sobre arrays</h2>
    <p>Algunas otras cosas que podemos hacer sobre arrays:</p>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:1rem;">
      <div class="fragment">
        <p>Comparaciones <br><small>(se usa mucho para indexar)</small></p>
        <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([1, 2, 3])
b = np.array([3, 2, 1])
print(a == b)  # array([False,  True, False])

        </code></pre>
      </div>
      <div class="fragment">
        <p>Ordenar<br><small>(También existe np.argsort para obtener los índices de ordenamiento)</small></p>
        <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([3, 1, 2])
print(np.sort(a))  # array([1, 2, 3])

        </code></pre>
      </div>
      <div class="fragment">
        <p>Funciones universales <small>(es decir, otras funciones matemáticas que ya vienen implementadas)</small></p>
        <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([1, 2, 3])
print(np.exp(a))  # array([ 2.718,  7.389, 20.085])
print(np.sqrt(a)) # array([1.000, 1.414, 1.732])
print(np.mean(a)) # 2.0

        </code></pre>
      </div>
      <div class="fragment">
        <p>Producto de matrices <br><small>(la operación más útil de la historia)</small></p>
        <pre><code class="python" data-line-numbers>
import numpy as np
a = np.array([[1, 2], [3, 4]])
b = np.array([[5, 6], [7, 8]])
print(a @ b)  # array([[19, 22],
              #        [43, 50]])

# También se pueden usar np.dot(a, b) o a.dot(b)
        </code></pre>
      </div>
    </div>
  </section>
  <section>
  <h2>En resumen...</h2>
  <ul>
    <li class="fragment">NumPy es una librería fundamental para el cálculo numérico en Python.</li>
    <li class="fragment">Los <em>ndarrays</em> son más eficientes que las listas de Python.</li>
    <li class="fragment">Los <em>ndarrays</em> tienen operaciones vectorizadas rápidas, que además simplifican código <br><small style="position:relative; left: 1050px;">(o lo complican, depende como las uses)</small></li>
    <li class="fragment">Hay muchas librerías que usan NumPy para implementar todo tipo de estructuras a partir de <span class="monospace">ndarray</span><br><small style="position:relative; left:1170px;"> (por ejemplo Pandas, que veremos en la siguiente clase!)</small></li>
    <li class="fragment" style="font-size: 110%;"><em>Puede que sea extremadamente aburrido aprender NumPy, pero también  es extremadamente útil.</em></li>
  </ul>
</section>
</div>
</div>
  <script src="dist/reveal.js"></script>
  <script src="plugin/notes/notes.js"></script>
  <script src="plugin/math/math.js"></script>
  <script src="plugin/markdown/markdown.js"></script>
  <script src="plugin/highlight/highlight.js"></script>
  <script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
      hash: true,
      katex: {
        version: 'latest',
        delimiters: [
          { left: '$$', right: '$$', display: true },
          { left: '$', right: '$', display: false },
          { left: '\\(', right: '\\)', display: false },
          { left: '\\[', right: '\\]', display: true },
        ],
        ignoredTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
      },
      // Learn about plugins: https://revealjs.com/plugins/
      plugins: [RevealMarkdown, RevealHighlight, RevealNotes, RevealMath.KaTeX]
    });
  </script>
  <script src="theme-toggle.js"></script>
</body>
</html>